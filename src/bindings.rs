/* automatically generated by rust-bindgen 0.71.1 */

pub const DQLITE_VERSION_MAJOR: u32 = 1;
pub const DQLITE_VERSION_MINOR: u32 = 18;
pub const DQLITE_VERSION_RELEASE: u32 = 3;
pub const DQLITE_VERSION_NUMBER: u32 = 11803;
pub const DQLITE_NODE_INFO_EXT_SZ_ORIG: u32 = 32;
extern "C" {
    pub fn dqlite_version_number() -> ::std::os::raw::c_int;
}
#[doc = " Hold the value of a dqlite node ID. Guaranteed to be at least 64-bit long."]
pub type dqlite_node_id = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dqlite_server {
    _unused: [u8; 0],
}
#[doc = " Signature of a custom callback used to establish network connections\n to dqlite servers.\n\n @arg is a user data parameter, copied from the third argument of\n dqlite_server_set_connect_func. @addr is a (borrowed) abstract address\n string, as passed to dqlite_server_create or dqlite_server_set_auto_join. @fd\n is an address where a socket representing the connection should be stored.\n The callback should return zero if a connection was established successfully\n or nonzero if the attempt failed."]
pub type dqlite_connect_func = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        addr: *const ::std::os::raw::c_char,
        fd: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Start configuring a dqlite server.\n\n The server will not start running until dqlite_server_start is called. @path\n is the path to a directory where the server (and attached client) will store\n its persistent state; the directory must exist. A pointer to the new server\n object is stored in @server on success.\n\n Whether or not this function succeeds, you should call dqlite_server_destroy\n to release resources owned by the server object.\n\n No reference to @path is kept after this function returns."]
    pub fn dqlite_server_create(
        path: *const ::std::os::raw::c_char,
        server: *mut *mut dqlite_server,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the abstract address of this server.\n\n This function must be called when the server starts for the first time, and\n is a no-op when the server is restarting. The abstract address is recorded in\n the Raft log and passed to the connect function on each server (see\n dqlite_server_set_connect_func). The server will also bind to this address to\n listen for incoming connections from clients and other servers, unless\n dqlite_server_set_bind_address is used. For the address syntax accepted by\n the default connect function (and for binding/listening), see\n dqlite_server_set_bind_address."]
    pub fn dqlite_server_set_address(
        server: *mut dqlite_server,
        address: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Turn on or off automatic bootstrap for this server.\n\n The bootstrap server should be the first to start up. It automatically\n becomes the leader in the first term, and is responsible for adding all other\n servers to the cluster configuration. There must be exactly one bootstrap\n server in each cluster. After the first startup, the bootstrap server is no\n longer special and this function is a no-op."]
    pub fn dqlite_server_set_auto_bootstrap(
        server: *mut dqlite_server,
        on: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Declare the addresses of existing servers in the cluster, which should\n already be running.\n\n The server addresses declared with this function will not be used unless\n @server is starting up for the first time; after the first startup, the list\n of servers stored on disk will be used instead. (It is harmless to call this\n function unconditionally.)"]
    pub fn dqlite_server_set_auto_join(
        server: *mut dqlite_server,
        addrs: *const *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configure @server to listen on the address @addr for incoming connections\n (from clients and other servers).\n\n If no bind address is configured with this function, the abstract address\n passed to dqlite_server_create will be used. The point of this function is to\n support decoupling the abstract address from the networking implementation\n (for example, if a proxy is going to be used).\n\n @addr must use one of the following formats:\n\n 1. \"<HOST>\"\n 2. \"<HOST>:<PORT>\"\n 3. \"@<PATH>\"\n\n Where <HOST> is a numeric IPv4/IPv6 address, <PORT> is a port number, and\n <PATH> is an abstract Unix socket path. The port number defaults to 8080 if\n not specified. In the second form, if <HOST> is an IPv6 address, it must be\n enclosed in square brackets \"[]\". In the third form, if <PATH> is empty, the\n implementation will automatically select an available abstract Unix socket\n path.\n\n If an abstract Unix socket is used, the server will accept only\n connections originating from the same process."]
    pub fn dqlite_server_set_bind_address(
        server: *mut dqlite_server,
        addr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configure the function that this server will use to connect to other servers.\n\n The same function will be used by the server's attached client to establish\n connections to all servers in the cluster. @arg is a user data parameter that\n will be passed to all invocations of the connect function."]
    pub fn dqlite_server_set_connect_func(
        server: *mut dqlite_server,
        f: dqlite_connect_func,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start running the server.\n\n Once this function returns successfully, the server will be ready to accept\n client requests using the functions below."]
    pub fn dqlite_server_start(server: *mut dqlite_server) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the ID of the server.\n\n This will return 0 (an invalid ID) if the server has not been started."]
    pub fn dqlite_server_get_id(server: *mut dqlite_server) -> dqlite_node_id;
}
extern "C" {
    #[doc = " Hand over the server's privileges to other servers.\n\n This is intended to be called before dqlite_server_stop. The server will try\n to surrender leadership and voting rights to other nodes in the cluster, if\n applicable. This avoids some disruptions that can result when a privileged\n server stops suddenly."]
    pub fn dqlite_server_handover(server: *mut dqlite_server) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop the server.\n\n The server will stop processing requests from client or other servers. To\n smooth over some possible disruptions to the cluster, call\n dqlite_server_handover before this function. After this function returns\n (successfully or not), you should call dqlite_server_destroy to free\n resources owned by the server."]
    pub fn dqlite_server_stop(server: *mut dqlite_server) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free resources owned by the server.\n\n You should always call this function to finalize a server created with\n dqlite_server_create, whether or not that function returned successfully.\n If the server has been successfully started with dqlite_server_start,\n then you must stop it with dqlite_server_stop before calling this function."]
    pub fn dqlite_server_destroy(server: *mut dqlite_server);
}
pub const DQLITE_OK: _bindgen_ty_1 = 0;
pub const DQLITE_ERROR: _bindgen_ty_1 = 1;
pub const DQLITE_MISUSE: _bindgen_ty_1 = 2;
pub const DQLITE_NOMEM: _bindgen_ty_1 = 3;
#[doc = " Error codes.\n\n These are used only with the dqlite_node family of functions."]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dqlite_node {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a new dqlite node object.\n\n The @id argument a is positive number that identifies this particular dqlite\n node in the cluster. Each dqlite node part of the same cluster must be\n created with a different ID. The very first node, used to bootstrap a new\n cluster, must have ID #1. Every time a node is started again, it must be\n passed the same ID.\n\n The @address argument is the network address that clients or other nodes in\n the cluster must use to connect to this dqlite node. If no custom connect\n function is going to be set using dqlite_node_set_connect_func(), then the\n format of the string must be \"<HOST>\" or \"<HOST>:<PORT\">, where <HOST> is a\n numeric IPv4/IPv6 address and <PORT> is a port number. The port number\n defaults to 8080 if not specified. If a port number is specified with an\n IPv6 address, the address must be enclosed in square brackets \"[]\".\n\n If a custom connect function is used, then the format of the string must by\n whatever the custom connect function accepts.\n\n The @data_dir argument the file system path where the node should store its\n durable data, such as Raft log entries containing WAL frames of the SQLite\n databases being replicated.\n\n No reference to the memory pointed to by @address and @data_dir is kept by\n the dqlite library, so any memory associated with them can be released after\n the function returns.\n\n Even if an error is returned, the caller should call dqlite_node_destroy()\n on the dqlite_node* value pointed to by @n, and calling dqlite_node_errmsg()\n with that value will return a valid error string. (In some cases *n will be\n set to NULL, but dqlite_node_destroy() and dqlite_node_errmsg() will handle\n this gracefully.)"]
    pub fn dqlite_node_create(
        id: dqlite_node_id,
        address: *const ::std::os::raw::c_char,
        data_dir: *const ::std::os::raw::c_char,
        n: *mut *mut dqlite_node,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy a dqlite node object.\n\n This will release all memory that was allocated by the node. If\n dqlite_node_start() was successfully invoked, then dqlite_node_stop() must be\n invoked before destroying the node."]
    pub fn dqlite_node_destroy(n: *mut dqlite_node);
}
extern "C" {
    #[doc = " Instruct the dqlite node to bind a network address when starting, and\n listening for incoming client connections.\n\n The given address might match the one passed to @dqlite_node_create or be a\n different one (for example if the application wants to proxy it).\n\n The format of the @address argument must be one of\n\n 1. \"<HOST>\"\n 2. \"<HOST>:<PORT>\"\n 3. \"@<PATH>\"\n\n Where <HOST> is a numeric IPv4/IPv6 address, <PORT> is a port number, and\n <PATH> is an abstract Unix socket path. The port number defaults to 8080 if\n not specified. In the second form, if <HOST> is an IPv6 address, it must be\n enclosed in square brackets \"[]\". In the third form, if <PATH> is empty, the\n implementation will automatically select an available abstract Unix socket\n path, which can then be retrieved with dqlite_node_get_bind_address().\n\n If an abstract Unix socket is used the dqlite node will accept only\n connections originating from the same process.\n\n No reference to the memory pointed to by @address is kept, so any memory\n associated with them can be released after the function returns.\n\n This function must be called before calling dqlite_node_start()."]
    pub fn dqlite_node_set_bind_address(
        n: *mut dqlite_node,
        address: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the network address that the dqlite node is using to accept incoming\n connections."]
    pub fn dqlite_node_get_bind_address(n: *mut dqlite_node) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set a custom connect function.\n\n The function should block until a network connection with the dqlite node at\n the given @address is established, or an error occurs.\n\n In case of success, the file descriptor of the connected socket must be saved\n into the location pointed by the @fd argument. The socket must be either a\n TCP or a Unix socket.\n\n This function must be called before calling dqlite_node_start()."]
    pub fn dqlite_node_set_connect_func(
        n: *mut dqlite_node,
        f: ::std::option::Option<
            unsafe extern "C" fn(
                arg: *mut ::std::os::raw::c_void,
                address: *const ::std::os::raw::c_char,
                fd: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " DEPRECATED - USE `dqlite_node_set_network_latency_ms`\n Set the average one-way network latency, expressed in nanoseconds.\n\n This value is used internally by dqlite to decide how frequently the leader\n node should send heartbeats to other nodes in order to maintain its\n leadership, and how long other nodes should wait before deciding that the\n leader has died and initiate a failover.\n\n This function must be called before calling dqlite_node_start()."]
    pub fn dqlite_node_set_network_latency(
        n: *mut dqlite_node,
        nanoseconds: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the average one-way network latency, expressed in milliseconds.\n\n This value is used internally by dqlite to decide how frequently the leader\n node should send heartbeats to other nodes in order to maintain its\n leadership, and how long other nodes should wait before deciding that the\n leader has died and initiate a failover.\n\n This function must be called before calling dqlite_node_start().\n\n Latency should not be 0 or larger than 3600000 milliseconds."]
    pub fn dqlite_node_set_network_latency_ms(
        t: *mut dqlite_node,
        milliseconds: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the failure domain associated with this node.\n\n This is effectively a tag applied to the node and that can be inspected later\n with the \"Describe node\" client request."]
    pub fn dqlite_node_set_failure_domain(
        n: *mut dqlite_node,
        code: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
pub const DQLITE_SNAPSHOT_TRAILING_STATIC: _bindgen_ty_2 = 0;
pub const DQLITE_SNAPSHOT_TRAILING_DYNAMIC: _bindgen_ty_2 = 1;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " !!! Deprecated, use `dqlite_node_set_snapshot_params_v2` instead which also includes\n trailing computation strategy. !!!\n\n Set the snapshot parameters for this node.\n\n This function determines how frequently a node will snapshot the state\n of the database and how many raft log entries will be kept around after\n a snapshot has been taken.\n\n `snapshot_threshold` : Determines the frequency of taking a snapshot, the\n lower the number, the higher the frequency.\n\n `snapshot_trailing` : Determines the maximum amount of log entries kept around after\n taking a snapshot. Lowering this number decreases disk and memory footprint\n but increases the chance of having to send a full snapshot (instead of a\n number of log entries to a node that has fallen behind).\n\n By default this function uses static trailing computation.\n\n This function must be called before calling dqlite_node_start()."]
    pub fn dqlite_node_set_snapshot_params(
        n: *mut dqlite_node,
        snapshot_threshold: ::std::os::raw::c_uint,
        snapshot_trailing: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the snapshot parameters for this node.\n\n This function determines how frequently a node will snapshot the state\n of the database and how many raft log entries will be kept around after\n a snapshot has been taken.\n\n `snapshot_threshold` : Determines the frequency of taking a snapshot, the\n lower the number, the higher the frequency.\n\n `snapshot_trailing` : Determines the maximum amount of log entries kept around after\n taking a snapshot. Lowering this number decreases disk and memory footprint\n but increases the chance of having to send a full snapshot (instead of a\n number of log entries to a node that has fallen behind).\n\n `trailing_strategy` : Determines the strategy used to compute the number of\n trailing entries to keep after a snapshot has been taken. Valid values are\n `DQLITE_SNAPSHOT_TRAILING_STATIC` and `DQLITE_SNAPSHOT_TRAILING_DYNAMIC`.\n\n `DQLITE_SNAPSHOT_TRAILING_STATIC` will use directly the value of `snapshot_trailing`\n as the number of entries to keep after a snapshot has been taken.\n\n `DQLITE_SNAPSHOT_TRAILING_DYNAMIC` will compute the number of entries to keep\n by comparing the size of the snapshot to the size of the entries. The idea behind\n this is that if the amount of memory (on-disk or RAM) needed to store log entities\n exceeds the amount of memory for snapshot, streaming the snapshot is more efficient.\n The amount of entries kept is still capped at `snapshot_trailing`.\n\n This function must be called before calling dqlite_node_start()."]
    pub fn dqlite_node_set_snapshot_params_v2(
        n: *mut dqlite_node,
        snapshot_threshold: ::std::os::raw::c_uint,
        snapshot_trailing: ::std::os::raw::c_uint,
        trailing_strategy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the block size used for performing disk IO when writing raft log segments\n to disk. @size is limited to a list of preset values.\n\n This function must be called before calling dqlite_node_start()."]
    pub fn dqlite_node_set_block_size(n: *mut dqlite_node, size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the target number of voting nodes for the cluster.\n\n If automatic role management is enabled, the cluster leader will attempt to\n promote nodes to reach the target. If automatic role management is disabled,\n this has no effect.\n\n The default target is 3 voters."]
    pub fn dqlite_node_set_target_voters(
        n: *mut dqlite_node,
        voters: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the target number of standby nodes for the cluster.\n\n If automatic role management is enabled, the cluster leader will attempt to\n promote nodes to reach the target. If automatic role management is disabled,\n this has no effect.\n\n The default target is 0 standbys."]
    pub fn dqlite_node_set_target_standbys(
        n: *mut dqlite_node,
        standbys: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the target number of threads in the thread pool processing sqlite3 disk\n operations.\n\n The default pool thread count is 4."]
    pub fn dqlite_node_set_pool_thread_count(
        n: *mut dqlite_node,
        thread_count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable or disable auto-recovery for corrupted disk files.\n\n When auto-recovery is enabled, files in the data directory that are\n determined to be corrupt may be removed by dqlite at startup. This allows\n the node to start up successfully in more situations, but comes at the cost\n of possible data loss, and may mask bugs.\n\n This must be called before dqlite_node_start.\n\n Auto-recovery is enabled by default."]
    pub fn dqlite_node_set_auto_recovery(
        n: *mut dqlite_node,
        enabled: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable or disable raft snapshot compression."]
    pub fn dqlite_node_set_snapshot_compression(
        n: *mut dqlite_node,
        enabled: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable automatic role management on the server side for this node.\n\n When automatic role management is enabled, servers in a dqlite cluster will\n autonomously (without client intervention) promote and demote each other\n to maintain a specified number of voters and standbys, taking into account\n the health, failure domain, and weight of each server.\n\n By default, no automatic role management is performed."]
    pub fn dqlite_node_enable_role_management(n: *mut dqlite_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the amount of time in milliseconds a write query can stay in the write\n queue before failing with SQLITE_BUSY.\n\n This is 0ms by default to keep backward compatibility."]
    pub fn dqlite_node_set_busy_timeout(
        n: *mut dqlite_node,
        msecs: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start a dqlite node.\n\n A background thread will be spawned which will run the node's main loop. If\n this function returns successfully, the dqlite node is ready to accept new\n connections."]
    pub fn dqlite_node_start(n: *mut dqlite_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attempt to hand over this node's privileges to other nodes in preparation\n for a graceful shutdown.\n\n Specifically, if this node is the cluster leader, this will cause another\n voting node (if one exists) to be elected leader; then, if this node is a\n voter, another non-voting node (if one exists) will be promoted to voter, and\n then this node will be demoted to spare.\n\n This function returns 0 if all privileges were handed over successfully,\n and nonzero otherwise. Callers can continue to dqlite_node_stop immediately\n after this function returns (whether or not it succeeded), or include their\n own graceful shutdown logic before dqlite_node_stop."]
    pub fn dqlite_node_handover(n: *mut dqlite_node) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop a dqlite node.\n\n The background thread running the main loop will be notified and the node\n will not accept any new client connections. Once inflight requests are\n completed, open client connections get closed and then the thread exits."]
    pub fn dqlite_node_stop(n: *mut dqlite_node) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dqlite_node_info {
    pub id: dqlite_node_id,
    pub address: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dqlite_node_info_ext {
    pub size: u64,
    pub id: u64,
    pub address: u64,
    pub dqlite_role: u64,
}
extern "C" {
    #[doc = " !!! Deprecated, use `dqlite_node_recover_ext` instead which also includes\n dqlite roles. !!!\n\n Force recovering a dqlite node which is part of a cluster whose majority of\n nodes have died, and therefore has become unavailable.\n\n In order for this operation to be safe you must follow these steps:\n\n 1. Make sure no dqlite node in the cluster is running.\n\n 2. Identify all dqlite nodes that have survived and that you want to be part\n    of the recovered cluster.\n\n 3. Among the survived dqlite nodes, find the one with the most up-to-date\n    raft term and log.\n\n 4. Invoke @dqlite_node_recover exactly one time, on the node you found in\n    step 3, and pass it an array of #dqlite_node_info filled with the IDs and\n    addresses of the survived nodes, including the one being recovered.\n\n 5. Copy the data directory of the node you ran @dqlite_node_recover on to all\n    other non-dead nodes in the cluster, replacing their current data\n    directory.\n\n 6. Restart all nodes."]
    pub fn dqlite_node_recover(
        n: *mut dqlite_node,
        infos: *mut dqlite_node_info,
        n_info: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Force recovering a dqlite node which is part of a cluster whose majority of\n nodes have died, and therefore has become unavailable.\n\n In order for this operation to be safe you must follow these steps:\n\n 1. Make sure no dqlite node in the cluster is running.\n\n 2. Identify all dqlite nodes that have survived and that you want to be part\n    of the recovered cluster.\n\n 3. Among the survived dqlite nodes, find the one with the most up-to-date\n    raft term and log.\n\n 4. Invoke @dqlite_node_recover_ext exactly one time, on the node you found in\n    step 3, and pass it an array of #dqlite_node_info filled with the IDs,\n    addresses and roles of the survived nodes, including the one being\n    recovered.\n\n 5. Copy the data directory of the node you ran @dqlite_node_recover_ext on to\n    all other non-dead nodes in the cluster, replacing their current data\n    directory.\n\n 6. Restart all nodes."]
    pub fn dqlite_node_recover_ext(
        n: *mut dqlite_node,
        infos: *mut dqlite_node_info_ext,
        n_info: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve information about the last persisted raft log entry.\n\n This is intended to be used in combination with dqlite_node_recover_ext, to\n determine which of the surviving nodes in a cluster is most up-to-date. The\n raft rules for this are:\n\n - If the two logs have last entries with different terms, the log with the\n   higher term is more up-to-date.\n - Otherwise, the longer log is more up-to-date.\n\n Note that this function may result in physically modifying the raft-related\n files in the data directory. These modifications do not affect the logical\n state of the node. Deletion of invalid segment files can be disabled with\n dqlite_node_set_auto_recovery.\n\n This should be called after dqlite_node_init, but the node must not be\n running."]
    pub fn dqlite_node_describe_last_entry(
        n: *mut dqlite_node,
        last_entry_index: *mut u64,
        last_entry_term: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a human-readable description of the last error occurred."]
    pub fn dqlite_node_errmsg(n: *mut dqlite_node) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Generate a unique ID for the given address."]
    pub fn dqlite_generate_node_id(address: *const ::std::os::raw::c_char) -> dqlite_node_id;
}
#[doc = " This type is DEPRECATED and will be removed in a future major release.\n\n A data buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dqlite_buffer {
    pub base: *mut ::std::os::raw::c_void,
    pub len: usize,
}
